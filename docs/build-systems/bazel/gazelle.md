---
id: gazelle
title: Gazelle
---

[Gazelle](https://github.com/bazelbuild/bazel-gazelle) is build file generator for Bazel projects. It natively supports protobuf. `rules_buf` houses a Gazelle extension for generating `buf_lint_test` and `buf_breaking_test` rules. We highly recommend using Gazelle to generate the build files.

## Setup
After [setting up](/build-systems/bazel/setup) `rules_buf`. Setup Gazelle according to these [instructions](https://github.com/bazelbuild/bazel-gazelle#setup).

Once that is done, modify the `BUILD` file with the `gazelle` target to include the `buf` extension:
```starlark title="BUIlD" {1-2,4-14,18}
-load("@bazel_gazelle//:def.bzl", "gazelle")
+load("@bazel_gazelle//:def.bzl", "gazelle", "gazelle_binary")

+gazelle_binary(
+    name = "gazelle-buf",    
+    languages = [
+        # Loads the native proto extension
+        "@bazel_gazelle//language/proto:go_default_library"
+        # Loads the Buf extension
+        #
+        # NOTE: This needs to be loaded after the proto language
+        "@rules_buf//gazelle/buf:buf",
+    ],
+)

gazelle(
    name = "gazelle",
+    gazelle = ":gazelle-buf",
)
```

Export the `buf.yaml` file by adding `exports_files(["buf.yaml"])` to the `BUILD` file.

> For workspaces do this for each `buf.yaml` file.

Now run Gazelle
```terminal
$ bazel run //:gazelle
```

## Lint

By default, a `buf_lint_test` rule is generated for each of the `proto_library` rule generated by Gazelle. It will pick up the `buf.yaml` that the protobuf package belongs to.

Run the following command to list the generated lint rules:
```terminal
$ bazel query 'kind(buf_lint_test, //...)'
```

## Breaking Change Detection

To generate breaking change detection rules we will need to add a gazelle [directive](https://github.com/bazelbuild/bazel-gazelle#directives) that points to an [image](/reference/images) target. Gazelle directives are top-level comments in build files. They can be used to configure Gazelle.

Add the following Gazelle directive:
```starlark
# gazelle:buf_breaking_against //:against_image_file
```
> The directive should be in the `BUILD` file at the root of the buf [module](bsr/overview#module). In other words, in the directory of `buf.yaml`.

`buf_breaking_test` rules can be generated in two different modes.

### Module mode (preferred)

This is the default and preferred mode. `buf_breaking_test` rule is generated for each buf module. The rule will reference all the `proto_library` rules that are part of a buf module. This way the test can detect if any files are deleted.

Once the `buf_breaking_against` directive is added, run `gazelle`:
```terminal
$ bazel run //:gazelle
```

Run the following command to list the generated breaking rules:
```terminal
$ bazel query 'kind(buf_breaking_test, //...)'
```

This mimics running `buf breaking` on a module. This is the most accurate way to check for breaking changes. However, depending on multiple targets at once is an anti-pattern in bazel. To do this the bazel way we have package mode.

### Package mode

Package mode generates `buf_breaking_test` rule for each of the `proto_library` rule. Allowing one to test only the `proto_library` that has changed. This could be useful in large codebases where checking the module can be time consuming.

To switch to package mode add the following Gazelle directive:
```starlark
# gazelle:buf_breaking_mode package
```

Now run Gazelle again:
```terminal
$ bazel run //:gazelle
```

Running the following command should show `buf_breaking_test` rules generated in multiple packages:
```terminal
$ bazel query 'kind(buf_breaking_test, //...)'
```

### Example: Module vs Package mode

Let's consider a buf module with the following directory structure:

```terminal
├── buf.yaml
├── BUILD
├── foo
│   └── v1
│       ├── foo.proto
│       └── BUILD
└── bar
    └── v1
        ├── bar.proto
        └── BUILD
```
#### Module mode

Single `buf_breaking_test` rule is generated in `BUILD`. If a breaking change occurs in either `foo.proto` or `bar.proto` the test will catch that. Even if `foo.proto` is deleted the test will catch that.

#### Package mode

`buf_breaking_test` rules are generated in both `foo/v1/BUILD` and `bar/v1/BUILD` against their respective `proto_library` targets. If a breaking change occurs in either `foo.proto` or `bar.proto` the tests will catch that. But if either `foo.proto` or `bar.proto` is deleted the tests will fail to catch that.