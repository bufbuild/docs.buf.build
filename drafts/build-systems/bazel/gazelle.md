---
id: gazelle
title: Gazelle
---

[Gazelle](https://github.com/bazelbuild/bazel-gazelle) is a build file generator for Bazel projects that natively supports Protobuf. `rules_buf` houses a Gazelle extension for generating `buf_lint_test` and `buf_breaking_test` rules. We highly recommend using Gazelle to generate the build files.

## Setup

Start by [setting up](overview) `rules_buf`, then setup Gazelle according to these [instructions](https://github.com/bazelbuild/bazel-gazelle#setup).

Modify the `BUILD` file with the `gazelle` target to include the `buf` extension:
```starlark title="BUIlD" {1-2,4-14,18}
-load("@bazel_gazelle//:def.bzl", "gazelle")
+load("@bazel_gazelle//:def.bzl", "gazelle", "gazelle_binary")

+gazelle_binary(
+    name = "gazelle-buf",    
+    languages = [
+        # Loads the native proto extension
+        "@bazel_gazelle//language/proto:go_default_library"
+        # Loads the Buf extension
+        #
+        # NOTE: This needs to be loaded after the proto language
+        "@rules_buf//gazelle/buf:buf",
+    ],
+)

gazelle(
    name = "gazelle",
+    gazelle = ":gazelle-buf",
)
```

Export the `buf.yaml` file by adding `exports_files(["buf.yaml"])` to the `BUILD` file.

> For workspaces do this for each `buf.yaml` file.

Now run Gazelle
```terminal
$ bazel run //:gazelle
```

Rerun Gazelle whenever something changes. 

## Lint

By default, a `buf_lint_test` rule is generated for each of the `proto_library` rule generated by Gazelle. It will pick up the `buf.yaml` that the Protobuf package belongs to.

Run this command to list the generated lint rules:

```terminal
$ bazel query 'kind(buf_lint_test, //...)'
```

## Breaking change detection

We need to add a gazelle [directive](https://github.com/bazelbuild/bazel-gazelle#directives) that points to an [image](/reference/images) target to generate breaking change detection rules. Gazelle directives are top-level comments in build files that are used to configure Gazelle.

> Refer to this [section](overview#against-image) for a overview how the image file itself can be maintained.

Add this Gazelle directive:

```starlark
# gazelle:buf_breaking_against //:against_image_file
```
> The directive should be in the `BUILD` file at the root of the buf [module](/bsr/overview#module). In other words, in the directory containing a `buf.yaml`.

`buf_breaking_test` rules can be generated in two different modes.

### Module mode (preferred)

This is the default and preferred mode. `buf_breaking_test` is generated for each buf module. The rule will reference all the `proto_library` rules that are part of a buf module. This way the test can detect if any files are deleted.

Once the `buf_breaking_against` directive is added, run `gazelle`:
```terminal
$ bazel run //:gazelle
```

Run this command to list the generated breaking rules:

```terminal
$ bazel query 'kind(buf_breaking_test, //...)'
```

This mimics running `buf breaking` on a module. This is the most accurate way to check for breaking changes. However, depending on multiple targets at once is an anti-pattern in bazel, so that's why we've provided package mode as an alternative.

### Package mode

Package mode generates a `buf_breaking_test` rule for each of the `proto_library` rule, which lets you test only the `proto_library` that has changed.

To switch to package mode, add this Gazelle directive:

```starlark
# gazelle:buf_breaking_mode package
```

Now run Gazelle again:
```terminal
$ bazel run //:gazelle
```

Running this command should show `buf_breaking_test` rules generated in multiple packages:

```terminal
$ bazel query 'kind(buf_breaking_test, //...)'
```

### Example: Module vs Package mode

Let's consider a buf module with this directory structure:

```terminal
├── buf.yaml
├── BUILD
├── foo
│   └── v1
│       ├── foo.proto
│       └── BUILD
└── bar
    └── v1
        ├── bar.proto
        └── BUILD
```
#### Module mode

A single `buf_breaking_test` rule is generated in `BUILD`. If a breaking change occurs in either `foo.proto` or `bar.proto` this test will detect it (even if `foo.proto` is deleted entirely).

Let's break down this scenario,
- A typical CI setup would be to use `bazel test //...` to run tests.
- When `foo.proto` is deleted, Gazelle needs to be run again to update the build files.
- This time when Gazelle runs, `buf_breaking_test` rule will have one less target: `["bar/v1:bar_proto"]`.
- The CI will run `bazel test //...`.
- The `buf_breaking_test` will detect the missing file and fail. 

#### Package mode

`buf_breaking_test` rules are generated in both `foo/v1/BUILD` and `bar/v1/BUILD` against their respective `proto_library` targets. If a breaking change occurs in either `foo.proto` or `bar.proto` these tests will detect it. However, if either `foo.proto` or `bar.proto` is deleted the tests will fail to detect it. 

Let's break down this scenario,
- A typical CI setup would be to use `bazel test //...` to run tests.
- When `foo.proto` is deleted, Gazelle needs to be run again to update the build files.
- This time when Gazelle runs, `foo/v1/BUILD` will no longer contain a `buf_breaking_test` rule.
- The CI will run `bazel test //...`.
- This will always pass as along with the file the test is also removed.
